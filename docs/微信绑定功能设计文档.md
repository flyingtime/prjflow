# 微信绑定功能设计文档

## 功能概述

允许已登录用户将自己的账号绑定到微信，绑定后可以使用微信扫码登录。

## 数据模型

### User 表
- `wechat_open_id`: 微信OpenID（指针类型，允许NULL）
- 已有字段，无需修改

## API设计

### 1. 获取微信绑定二维码
**接口**: `GET /api/auth/wechat/bind/qrcode`  
**认证**: 需要登录（Auth中间件）  
**响应**:
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "ticket": "ticket_xxx",
    "qr_code_url": "https://open.weixin.qq.com/connect/qrconnect?...",
    "auth_url": "https://open.weixin.qq.com/connect/qrconnect?...",
    "expire_seconds": 600
  }
}
```

### 2. 处理微信绑定回调
**接口**: `GET /api/auth/wechat/bind/callback`  
**认证**: 不需要（微信直接重定向）  
**参数**: 
- `code`: 微信授权码
- `state`: 状态参数（包含ticket和user_id）

**处理逻辑**:
1. 从state中提取ticket和user_id
2. 获取微信用户信息
3. 检查该微信OpenID是否已被其他用户绑定
4. 如果已被绑定，返回错误
5. 如果未绑定，更新当前用户的wechat_open_id
6. 通过WebSocket通知PC前端绑定成功

**响应**: HTML页面（在微信内显示）

### 3. 解绑微信
**接口**: `POST /api/auth/wechat/unbind`  
**认证**: 需要登录（Auth中间件）  
**响应**:
```json
{
  "code": 200,
  "message": "success",
  "data": {
    "message": "解绑成功"
  }
}
```

## 业务逻辑

### 绑定流程
1. 用户点击"绑定微信"按钮
2. 前端调用获取二维码接口
3. 显示二维码，用户扫码
4. 微信重定向到回调接口
5. 后端处理绑定逻辑
6. 通过WebSocket通知PC前端绑定成功
7. 前端刷新用户信息

### 验证规则
1. 用户必须已登录
2. 如果用户已绑定微信，需要先解绑才能绑定新的
3. 如果微信已被其他用户绑定，不能重复绑定
4. 绑定成功后，更新用户的wechat_open_id和avatar（可选）

### 解绑流程
1. 用户点击"解绑微信"按钮
2. 前端调用解绑接口
3. 后端将用户的wechat_open_id设置为NULL
4. 前端刷新用户信息

## 前端实现

### 用户信息页面
在 `AppHeader.vue` 或用户设置页面添加：
- 显示微信绑定状态（已绑定/未绑定）
- "绑定微信"按钮（未绑定时显示）
- "解绑微信"按钮（已绑定时显示）
- 绑定二维码弹窗（使用WeChatQRCode组件）

### API接口
在 `frontend/src/api/auth.ts` 中添加：
- `getWeChatBindQRCode()`: 获取绑定二维码
- `unbindWeChat()`: 解绑微信

## 测试用例

### 单元测试
1. 获取绑定二维码（需要登录）
2. 处理绑定回调（成功场景）
3. 处理绑定回调（微信已被绑定）
4. 处理绑定回调（用户已绑定其他微信）
5. 解绑微信（成功场景）
6. 解绑微信（未绑定场景）

## 注意事项

1. state参数格式：`bind:{ticket}:{user_id}`，用于在回调时识别用户
2. 绑定回调需要验证用户身份，通过state中的user_id
3. WebSocket通知使用ticket作为连接标识
4. 解绑后，用户仍可以使用用户名密码登录

